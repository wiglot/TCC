\chapter{Metodos Heurísticos para o CCP}
% ##################Falar sobre todos os métodos estudados

O CCP, é descrito na literatura como um problema $\mathcal{NP}-completo$\cite{garey1979computers},
não existindo algoritmos em tempo polinomial para resolver o problema de forma ótima.
Para os métodos exatos, que apresentam melhores soluções, eles somente
podem ser utilizados para instância pequenas (<100 indivíduos), uma
vez que é um problema de programação inteira e o numéro de variaveis
de decisão é da ordem de $n^{2}+n$\cite{RePEc:eee:ejores:v:18:y:1984:i:3:p:339-348},
onde $n$ é o número pontos de demanda do problema. Para instâncias
muito grandes, o uso de heurísticas traz soluções muito boas, algumas
vezes muito próximas aos métodos exatos. Serão apresentadas algumas
heurísticas construtivas para o CCP:
\begin{description}
\item [{Farthest:}] Proposta por Osman e Christofides em \cite{osman1994capacitated},
tem como base escolher os pontos mais afastados para serem os primeiros
centros
\item [{Density:}] Proposta por Ahmadi e Osman em \cite{ahmadi2004density},
visa construir uma solução inicial usando a densidade de pontos para
construir a solução inicial.
\item [{H-Means:}] O método de Forgy ((também conhecido, e tratado aqui, como H-Means) foi inicialmente proposto por \cite{forgy1965cluster} e tem como principio  a procura iterativa dos melhores centros para os agrupamentos realocando os pontos a cada troca.
\item [{J-Means:}] Proposta pos Hansen e Mladenovi\'{c}\cite{Hansen_j-means:a}, usa a noção de pontos ocupados e não ocupados (a uma certa distância do agrupamento).
\end{description}
% \item [{CCCP}]~
%
% \begin{description}
% \item [{Balanced}] q-trees: que utiliza de arvores q-trees e métodos como
% k-means, Forgy, entre outros
% \item [{Unconstrained}] to Constrained: inicia como uma solução infactível
% alterando-a até conseguir uma solução factível. Ambos métodos para
% CCCP apresentados em \cite{negreiros2006capacitated};
% \end{description}

\section{CCP}

Para o problema de agrupamento capacitado (CCP), apresentamos 2 heurísticas:


\subsection{Farthest}

Osman e Christofides apresentaram a heuristica construtiva com base
no afastamento inicial dos primeiros centros (mais afastados entre
sí) e após um recálculo dos centros de cada agrupamento. Essa é uma
heuristica muito rápida mas que pode não encontrar soluções factíves
para o caso de a soma de todas demandas seja muito próxima das capacidades
de todos agrupamentos. A heurística pode ser apresentada da seguinte
forma:
\begin{itemize}
\item Passo 1 - encontre os pontos $(i,j)$ mais afastados entre sí, então
$C={i,j}$

\begin{itemize}
\item Se número desejado de agrupamentos (p) = 2, vá para o passo 3.
\end{itemize}
\item Passo 2 - enquanto |C| < número desejado de agrupamento, faça

\begin{itemize}
\item Encontre um cento $k\in O-C$, de modo que:
\end{itemize}
\[
\prod_{j\in C}d_{kj}=\max_{_{k\in O-C}}\;\;\prod_{j\in C}d_{kj}\]

\begin{itemize}
\item Então faça $C=C\cup k$;
\end{itemize}
\item Passo 3 - Para cada consumidor, encontre a distância até o centro
mais próximo. Organize estas distâncias em ordem crescentedo. Atribua
os consumidores na ordem dessas distâncias aos centros correspondentes,
se a capacidade permitir, caso contrário, atribua para o centro mais
próximo disponível.
\item Passo 4 - Recalcule os centros dos agrupamentos de modo a minimizar
as distância entre os pontos e o novo centro.
\end{itemize}
Essa heuristica tem como objetivo a construção rápida de uma solução
e para se obter melhores soluções deve-se empregar heuristicas de
busca na visinhança da solução obtida com essa heuristica construtiva.
Em \cite{osman1994capacitated} é apresentado um método híbrido que
combina Busca tabu e simulated annealing.


\subsection{Density}

Para resolver um problema de agrupamento uma abordagem possível para
escolha dos centros iniciais é a escolha dos centros que possuam uma
maior densidade de pontos, assim a distância entre esse centro candidato
e os possíveis pontos componentes será minimizada. Essa abordagem
tem carater guloso e é miope por escoher os pontos candidatos a centros
vendo apenas sua densidade sem prever o rumo que essa solução está
tomando. Para corrigir isso, é apresentado um método baseado na idéia
de densidade dos pontos, mas que utiliza de aspectos computação adaptativa
com uma contrução-desconstrução periódica. Essa meta-heuristica construtiva
apresenta solucçoes muito boas em uma iteração, sendo as melhoras
sobre a solução dada por uma procura no espaço do problema através
de alterações nas distâncias e e geração de novas soluções.

Para a etapa construtiva da solução, existem os seguintes métodos:
\begin{itemize}
\item EncontraVizinhos: Encontra os $m_{i}$vizinhos mais próximos de ponto
$i$, sendo que $m_{i}\leq\frac{n}{p}$ e todos os pontos $Y_{i}$
(conjunto de pontos vizinhos do centro $i$) tem a soma de suas demandas
inferior ou igual a capacidade do agrupamento $i$.
\item CalculaDensidade: Com o conjunto de pontos vizinhos do centro $i$,
conseguimos calcular a densidade do centro através de
\end{itemize}
\[
D_{i}=\frac{m_{i}}{T(a_{i},Y_{i})}\]


sendo $T(a_{i},Y_{k})$ a função que devolve a distância total de
do ponto $a_{i}$ até todos os pontos de $Y_{k}$.
\begin{itemize}
\item CalculaArrependimento: Após encontrados os pontos candidatos a centros,
é necessário definir os pontos que serão atribuidos a cada um dos
agrupamentos. Para essa inserção, é utilizada essa função para calcular
o arrependimento de associar um nó com um centro que não seja o mais
próximo. Para um ponto $i$, tendo os pontos $j_{1}\; e\; j_{2}$
como o centro mais próximo a $i$ e segundo mais próximo, respectivamente,
calculamos o arrependimento de associar $i$ com um centro que não
seja $j_{1}$ como sendo:
\end{itemize}
\[
R_{i}=d_{ij_{2}}-\; d_{ij_{1}}\]

\begin{itemize}
\item EncontreOsMelhoresAgrupamentos (C, A): tendo A como um conjunto de
pontos e C o conjunto de centros. Essa função tenta associar os pontos
em A com os agrupamentos em C e está descrita em \ref{alg:;EncontreOsMelhoresAgrupamentos}.
\end{itemize}
%
\begin{algorithm}
\caption{\label{alg:;EncontreOsMelhoresAgrupamentos}EncontreOsMelhoresAgrupamentos(C,A)} %\protect \\}


$t=1$;

Minor $\leftarrow$ Máximo de iterações;

$alterado\leftarrow Verdadeiro$;

Enquanto ($alterado=Verdadeiro$ E $t<Minor$)

Faça:

~~~~~~$alterado\leftarrow False$;

~~~~~~1: Atribua todos os centros aos seus agrupamentos;

~~~~~~2: Calcule o arrependimento de todos os pontos em $A$;

~~~~~~3: Encontre o maior $R_{i}$ não atribuido;

~~~~~~4: Atribua $i$ para o agrupamento mais próximo disponível;

~~~~~~5: Atualiza $A$ com os pontos atribuidos;

~~~~~~6: Se $A\neq\emptyset$, vá para 2;

~~~~~~Para cada $C_{j}$ e seu centro $c_{j}$

~~~~~~~~~~~para cada $a_{i}\in C_{j}$

~~~~~~~~~~~~~~~~Se ($T(a_{i},C_{j})<T(c_{j},C_{j})$)

~~~~~~~~~~~~~~~~~~~~Atualize o novo centro de
$C_{j}$ como $a{}_{i}$;

~~~~~~~~~~~~~~~~~~~~$alterado\leftarrow Verdadeiro$;

~~~~~~~~~~~~~~~~FimSe;

~~~~~~~~~~FimPara;

~~~~~~FimPara;

~~~~~~$t\leftarrow t+1$;

FimFunção.
\end{algorithm}


Com as funções definidas, um procedimento principal é chamado e apresenta
ao final o conjunto dos agrupamentos $C$. Em \ref{alg:ProcedimentoDensidade}
é apresentado tal procedimento o qual implementa a computação adaptativa.
De modo iterativo, esse método vai construindo um agrupamento por
vez e recalculando a densidade ($D)$ e arrependimento ($R$) do conjunto.

%
\begin{algorithm}
\caption{{ProcedimentoPrincipal}\label{alg:ProcedimentoDensidade}}
% \begin{algorithmic}
I: conjunto de $n$ pontos

C: conjunto de centros

X: conjunto de pontos não atribuidos em A

Z: conjunto de pontos atribuidos até iteração $k$

$Y_{i}$: conjunto dos $m_{i}$ pontos próximos a $a_{i}$, dado pela
função $EncontraVizinhos$

Passo 1:

$k=0;$

$X=A,\, C=\emptyset,\, Z=\emptyset$

Passo 2:

$k\leftarrow k+1;$

Para cada $a_{i}\in X$, encontre o conjunto $m_{i}$, $Y_{i}\subseteq X$;

Calcule a densidade ($D_{i}$) para cada $a_{i}\in X$;

Selecione o maior $D_{i}$ e atribua $a_{i}$ como centro do centro
do $k$-ésimo agrupamento, $C_{k}=C_{k}\cup a_{i}$;

Elimine os pontos selecionados das próximas seleções: $X=X\setminus Y_{i}$,
$Y=Y\cup Y_{i}$;

Se $k\geq2$ então chame $EncontreOsMelhoresAgrupamentos(C,Y)$;

Se $k<p$ então volte ao passo 2;

$EncontreOsMelhoresAgrupamentos(C,A)$

% \end{algorithmic}
\end{algorithm}

\subsection{H-Means}
A idéia básica desse algoritmo é partindo de um conjunto de medianas, escolhidas de maneira aleatória, alocar cada um dos pontos ao agrupamento de mediana mais próxima a ele e, ao final dessa etapa, para cada agrupamento $j = {1,..,p}$ encontrar um ponto $k$ para ser a nova mediana do agrupamento $j$ de modo que
$$ \sum_{i\in P_{j}} c_{i,k} = \text{MIN}_{i\in P_{j}} \sum_{i\in P_{j}} c_{i,k}$$

Move pontos para agrupamentos, depois escolhe os melhores centros. Desassocia os pontos dos agrupamento e associa para os centros mais próximos. O algoritmo pode ser visto em \ref{alg:HMeans}

\begin{algorithm}
\caption{{H-Means}\label{alg:HMeans}}
\begin{enumerate}
 \item Selecione $p$ pontos como medianas iniciais;

 \item Aloque cada indivíduo ao agrupamento com mediana mais próxima a ele;

\item Caso não tenha ocorrido alteração de associações Pare.

\item Encontre o melhor centro para cada agrupamento e volte ao passo 2;
\end{enumerate}
\end{algorithm}


\subsection{J-Means}
Essa heurística proposta por \cite{Hansen_j-means:a} utiliza a idéia de indivíduos não ocupados (indivíduos que se encontram afastadas da mediana do agrupamento por uma certa tolerância), para criar um novo agrupamento em alguma desses indivíduos que substitua algum dos agrupamentos existentes, de modo a diminuir o valor da função objetivo.

\begin{algorithm}[ht]
\caption{{J-Means}\label{alg:JMeans}}
\begin{enumerate}
 \item Selecione $p$ partições dos pontos que serão os agrupamentos. Armazene essa solução em $S*$.

 \item Encontre os pontos não ocupados (afastados do centro do agrupamento por uma tolerância)

 \item Para cada ponto não ocupado, tente substituir um centro existente por ele e reatribua os pontos aos agrupamentos de medianas mais próximas. Mantenha o que apresentar maior redução na função objetivo armazenando-a em $S'$

 \item Se valor da função objetivo da solução nova $S'$ é menor que a de $S*$ faça $S*=S'$'e volte ao passo 2. Caso contrario Pare.

\end{enumerate}
\end{algorithm}

A escolha das partições inicias é feita de forma aleatória, selecionando as medianas e para todos indivíduos, atribua-os ao agrupamento mais próximo com capacidade disponível para atender a demanda do indivíduo.


Uma comparação entre as soluções geradas pelas heurísticas pode ser
visto na figura \ref{fig:CCP-compara=0000E7=0000E3o}. A Instância
é a mesma aplicada em ambos casos. Como podemos ver, a heurística
de densidade apresenta um solução melhor, apesar do tempo de processamento
ser muito alto pela complexidade do algoritmo.

% %
\begin{figure}[ht]
\begin{centering}
\subfloat[]{
% \begin{center}
 \includegraphics[scale=0.4,keepaspectratio=true]{../TCC-I/imagens/cluster_Density_SJC4a.png}\label{a}
 % cluster_Density_SJC4a.png: 523x527 pixel, 83dpi, 16.00x16.13 cm, bb=0 0 454 457
% \end{center}

}
\subfloat[]{
% \begin{center}
 \includegraphics[scale=0.4,keepaspectratio=true]{../TCC-I/imagens/cluster_Farthest_SJC4a.png}\label{b}
 % cluster_Farthest_SJC4a.png: 510x508 pixel, 83dpi, 15.61x15.54 cm, bb=0 0 442 441
% \end{center}

% \includegraphics[scale=0.4]{../TCC-I/imagens/cluster_Farthest_SJC4a.png}\label{b}
}
\par

\caption[Comparação heurísticas Density-Farthest]{\label{fig:CCP-compara=0000E7=0000E3o}A solução gerada pela heurística
Density \subref{a} possui os agrupamentos bem mais compactos que na
solução pela heurística Farthest \subref{b}.}
\end{centering}
\end{figure}

\section{Busca Local}
Apartir dos resultados obtidos anteriormente, como é e o que um método de busca local pode fazer.
Usando os movimentos descritos por \cite{osman1994capacitated} de interchange (intercâmbio) e shift (mudança) temos os mecanismos de geração das soluções vizinhas à atual. Ambos movimento devem respeitar a capacidade cada agrupamento, não inserindo um indivíduo que ultrapasse tal capacidade.

O movimento shift é uma troca simples onde apenas é removido um indivíduo $i$ de um agrupamento $C$ e o mesmo indivíduo é inserido em um outro agrupamento $C'$, sendo $C \neq C'$ e $C'$ possui capacidade suficiente para atender a demanda de $i$. Esse movimento não permite grande exploração da vizinhança, uma vez que para executar-lo é necessário que exista uma capacidade ociosa nos agrupamentos para receber novos pontos. Na figura \ref{shiftExample} é apresentado um exemplo de movimento shift executado em uma solução válida do problema.

\begin{figure}[ht]
\begin{centering}
\subfloat[]{
 \includegraphics[scale=0.6]{../apresentacao_andamento/before_shift.png}% \label{a}
 % before_shift.png: 414x232 pixel, 96dpi, 10.95x6.14 cm, bb=0 0 310 174

}
\subfloat[]{
 \includegraphics[scale=0.6]{../apresentacao_andamento/after_shift.png}% \label{b}
 % after_shift.png: 414x232 pixel, 96dpi, 10.95x6.14 cm, bb=0 0 310 174
}
\par
\caption[Exemplo movimento Shift]{Em \ref{a} temos uma solução com 2 agrupamentos e em \ref{b} uma solução vizinha após movimento de shift.}\label{shiftExample}
\end{centering}
\end{figure}


O movimento de interchange, visa trocar um indivíduo $i'$ de um agrupamento $C'$ por um outro indivíduo $i$ de um outro agrupamento $C$, sendo $i \neq i'$ e $C \neq C'$.
Esse movimento permite que sejam encontradas novas soluções vizinhas a atual mesmo quando os agrupamentos se encontram com demanda alta (pouca capacidade disponível), pois a troca é feita em um único momento sem que necessariamente um agrupamento deva ter capacidade suficiente para receber um ponto extra. Nas figuras em \ref{interchangeExample}, pode ser visto o movimento interchange, sendo em (a) os agrupamentos existentes e que permitem a troca dos pontos entre si pelo movimento interchange e em (b) a solução obtida pelo movimento.
\begin{figure}[ht]
\begin{centering}
\subfloat[]{
 \includegraphics[scale=0.6]{../apresentacao_andamento/before_interchange.png}% \label{a}
 % before_shift.png: 414x232 pixel, 96dpi, 10.95x6.14 cm, bb=0 0 310 174

}
\subfloat[]{
 \includegraphics[scale=0.6]{../apresentacao_andamento/after_interchange.png}% \label{b}
 % after_shift.png: 414x232 pixel, 96dpi, 10.95x6.14 cm, bb=0 0 310 174
}
\par
\caption[Exemplo movimento interchange]{Em \ref{a} temos uma solução com 2 agrupamentos e em \ref{b} uma solução vizinha após movimento de interchange.} \label{interchangeExample}
\end{centering}
\end{figure}

Ao final de cada movimento, as medianas são recalculadas de modo a minimizar a função objetivo do problema.


Para busca local, foram implemetados 2 algoritmos, ambos usando uma busca gulosa na vizinhança por soluções com valores da função objetivo menores e cada um deles usando um dos movimentos acima descritos.

Para o algoritmo com o movimento shift, chamdo internamente na ferramenta computacional ShiftHillClimb, ele faz uma busca completa de todas possibilidades de mudança do indivíduo do agrupamento atual para os demais, efetuando a troca do indivíduo que dê um maior ganho para a função objetivo. Ele segue o algoritmo apresentado em \ref{alg:ShiftHillClimb}. Esse algoritmo é executatod iterativamente até que não existam soluções vizinha com uma função objetivo menor (um mínimo local) e tem  complexidade de $O(n\cdot p)$ para cada iteração.
\begin{algorithm}
\caption{{ShiftHillClimb}\label{alg:ShiftHillClimb}}
\begin{algorithmic}[1]
\STATE $MelhorSol \leftarrow AtualSol $
\REPEAT
\STATE $NovaSol \leftarrow MelhorSol$
\FORALL {$i \in I$}
\STATE Procura a melhor troca de i para um dos demais p-1 agrupamentos
\ENDFOR
\STATE $NovaSol \leftarrow melhor movimento de Shift$
\UNTIL{NovaSol $<$ MelhorSol }
\end{algorithmic}
\end{algorithm}

O algoritmo de busca local implementado usando o movimento de interchange, originalmente tentava executar a troca de um ponto com todos os pontos dos demais agrupamentos que não o seu. Isso o deixava com uma complexidade $O(n \cdot (p-1) \cdot \frac{n}{p})$, algo muito próximo a $O(n^{2})$ para cada iteração.Para reduzir o espaço de busca do algoritmo, uma vez que muitos dos intercâmbios não geram soluções melhores, implementamos o algoritmo \ref{alg:InterchangeHillClimb}.
\begin{algorithm}
\caption{{InterchangeHillClimb}\label{alg:InterchangeHillClimb}}
\begin{algorithmic}[1]
\STATE $MelhorSol \leftarrow AtualSol $
\REPEAT
\STATE $NovaSol \leftarrow MelhorSol$
\FORALL {$i \in I$}
\STATE A R R U M A R    I S S O ! ! !
\ENDFOR
\STATE $NovaSol \leftarrow melhor movimento de Shift$
\UNTIL{NovaSol $<$ MelhorSol }
\end{algorithmic}
\end{algorithm}